#include "QueryCompiler.h"
#include "QueryOptimizer.h"
#include "Schema.h"
#include "ParseTree.h"
#include "Record.h"
#include "DBFile.h"
#include "Comparison.h"
#include "Function.h"
#include "RelOp.h"

using namespace std;


QueryCompiler::QueryCompiler(Catalog& _catalog, QueryOptimizer& _optimizer) :
	catalog(&_catalog), optimizer(&_optimizer) {
}

QueryCompiler::~QueryCompiler() {
}

void QueryCompiler::Compile(TableList* _tables, NameList* _attsToSelect,
	FuncOperator* _finalFunction, AndList* _predicate,
	NameList* _groupingAtts, int& _distinctAtts,
	QueryExecutionTree& _queryTree) {

	// create a SCAN operator for each table in the query
    TableList * tables = _tables;
    
    while ( tables != NULL ) {
        DBFile db_file;
        Schema scan_schema;
        string tbl_name{tables->tableName};
		//cout<<"Tables are : "<<tables->tableName<<endl;

		catalog->GetSchema(tbl_name,scan_schema);
		Scan * scan=new Scan(scan_schema,db_file);
		// cout<<"Scan \n"<<tbl_name<<" : "<<scan<<endl;
		pushDown[tbl_name]=(RelationalOp*) scan;
		

		CNF cnf;
		Record record;
		cnf.ExtractCNF(*_predicate,scan_schema,record);
//		cout<<"cnf.numAnds "<<cnf.numAnds<<endl;


		//cout<<"Producer "<<all_scan.at(tbl_name)<<(RelationalOp*)& "SCAN";//<<"Record "<<record.print(scan_schema)<<endl;
		// push-down selections: create a SELECT operator wherever necessary
		if(cnf.numAnds != 0){
			Select * select= new Select(scan_schema,cnf,record,(RelationalOp*) scan);
			//cout<<"Producer "<<(RelationalOp*) & all_scan.at(tbl_name)<<endl;
			pushDown[tbl_name]=(RelationalOp*) select;
			// cout<<"Select \n"<<tbl_name<<" : "<<select<<endl;
		}

		tables=tables->next;
	}

	

	// call the optimizer to compute the join order
	OptimizationTree* root;
	optimizer->Optimize(_tables, _predicate, root);

//	cout<<"IN COMPILLER"<<endl;
//	printTree(root);


	// create join operators based on the optimal order computed by the optimizer
    OptimizationTree * jo_root=root;
    printTree(root);

    RelationalOp* relop=joinTree(jo_root,_predicate,pushDown);
	// create the remaining operators based on the query
	
	

	// connect everything in the query execution tree and return

	// free the memory occupied by the parse tree since it is not necessary anymore
}

RelationalOp* QueryCompiler::joinTree(OptimizationTree* root, AndList* _predicate,unordered_map<string,RelationalOp*> pushDown)
{
	if(root->leftChild==NULL && root->rightChild==NULL)
	{
		return pushDown.find(root->tables[0])->second;
	}
	else
	{
		RelationalOp* leftRop=joinTree(root->leftChild,_predicate,pushDown);
		RelationalOp* rightRop=joinTree(root->rightChild,_predicate,pushDown);

		Schema leftSchema,rightSchema,outSchema;
		CNF cnf;
		leftSchema=leftRop->returnSchema();
		rightSchema=rightRop->returnSchema();
		cnf.ExtractCNF(*_predicate,leftSchema,rightSchema);
		outSchema.Append(leftSchema);
		outSchema.Append(rightSchema);
		cout<<"OutSchema : "<<outSchema<<endl;
		Join* join=new Join(leftSchema,rightSchema,outSchema,cnf,leftRop,rightRop);
		return (RelationalOp*) join;
	}
	
    // cout<<"Selection :"<<endl;
	// if(root->rightChild== NULL && root->leftChild==NULL)
	// {
	// 	RelationalOp * relop;
	// 	stringstream ss1;
    //     string temp;
    //     ss1<<root->tables[0];ss1>>temp;
	// 	//cout<<"Selection :"<<temp<<endl;
	// 	auto itr=all_select.find(temp);
	// 	if(itr!=all_select.end())
	// 	{
	// 		relop=(RelationalOp*) & itr->second;
	// 	}
	// 	else relop=(RelationalOp*) & all_scan.at(itr->first);
		
	// }

	// //cout<<"Selection : "<<root->leftChild->tables.size()<<" "<<root->rightChild->tables.size()<<endl;
	// if(root->leftChild->tables.size()==1 && root->rightChild->tables.size()==1)
	// {
	// 	string leftC=root->leftChild->tables[0];
	// 	string rightC=root->rightChild->tables[0];
	// 	cout<<leftC<<" "<<rightC<<endl;
	// }

	// if(root->leftChild->tables.size()==1)
    // {
    //     cout<<"Left"<<endl;
    // }

	// if(root->rightChild->tables.size()==1)
    // {
    //     cout<<"Right"<<endl;
    // }
}

void QueryCompiler::printTree(OptimizationTree* & root)
{
    if(root->leftChild==NULL && root->rightChild==NULL)
    {
        cout<<root->tables[0]<<" # ";
        return;
    }
    printTree(root->leftChild);
    printTree(root->rightChild);
}